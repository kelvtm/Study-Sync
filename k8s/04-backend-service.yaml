# ============================================
# Backend Service
# ============================================
#
# CONCEPT: Service provides stable network endpoint for Pods
#
# WHY SERVICES?
# Problem: Pods have dynamic IPs (change on restart)
# Solution: Service provides stable DNS name and IP
#
# HOW IT WORKS:
# 1. Service has stable ClusterIP (e.g., 10.96.0.1)
# 2. Service has DNS name (e.g., backend-service.studysync-dev.svc.cluster.local)
# 3. Service uses selector to find Pods (matches labels)
# 4. Service load balances traffic across all matching Pods
#
# REAL-WORLD ANALOGY:
# - Pods = Individual employees (come and go)
# - Service = Company phone number (always the same)
# - Calls to company number → routed to available employees
# ============================================

apiVersion: v1
kind: Service
metadata:
  name: backend
  namespace: studysync-dev
  labels:
    app: studysync
    component: backend
  annotations:
    description: "Backend API Service"
spec:
  # ============================================
  # SERVICE TYPE
  # ============================================
  # ClusterIP (default): Internal only, accessible within cluster
  # NodePort: Exposes on each node's IP at a static port
  # LoadBalancer: Cloud load balancer (AWS ELB, etc.)
  # ExternalName: Maps to external DNS name
  type: ClusterIP

  # LEARNING NOTE: We use ClusterIP because:
  # - Backend should only be accessible from within cluster
  # - Frontend will connect to this service
  # - Ingress will route external traffic

  # ============================================
  # SELECTOR: Which Pods does this Service target?
  # ============================================
  selector:
    app: studysync
    component: backend

  # LEARNING NOTE: Service matches Pods with these labels
  # Even if Pods restart and get new IPs, Service finds them

  # ============================================
  # PORTS: Service exposes these ports
  # ============================================
  ports:
    - name: http
      protocol: TCP
      port: 3000 # Port Service listens on
      targetPort: 3000 # Port on the Pod (container port)

  # LEARNING NOTE: Port mapping
  # Other Pods connect to: studysync-backend:3000
  # Service forwards to: Pod's port 3000

  # ============================================
  # SESSION AFFINITY (Optional)
  # ============================================
  # sessionAffinity: ClientIP
  # sessionAffinityConfig:
  #   clientIP:
  #     timeoutSeconds: 10800

  # LEARNING NOTE: Session Affinity
  # - None (default): Each request can go to different Pod
  # - ClientIP: Requests from same client go to same Pod
  # Use case: Sticky sessions, stateful apps

# ============================================
# HOW TO ACCESS THIS SERVICE:
# ============================================
#
# From within the cluster (same namespace):
#   curl http://studysync-backend:3000/api/health
#
# From within the cluster (different namespace):
#   curl http://studysync-backend.studysync-dev.svc.cluster.local:3000/api/health
#
# From outside the cluster (using kubectl port-forward):
#   kubectl port-forward service/studysync-backend 3000:3000 -n studysync-dev
#   curl http://localhost:3000/api/health
#
# Service DNS pattern:
#   <service-name>.<namespace>.svc.cluster.local
# ============================================

---
# ============================================
# Headless Service (Optional - For StatefulSets)
# ============================================
# CONCEPT: Service without ClusterIP
# Used when you need to connect to specific Pods
# ============================================

apiVersion: v1
kind: Service
metadata:
  name: studysync-backend-headless
  namespace: studysync-dev
  labels:
    app: studysync
    component: backend
spec:
  type: ClusterIP
  clusterIP: None # Makes it "headless"
  selector:
    app: studysync
    component: backend
  ports:
    - name: http
      port: 3000
      targetPort: 3000
# LEARNING NOTE: Headless Service
# Returns Pod IPs instead of Service IP
# DNS returns A records for each Pod
# Use case: StatefulSets, databases (need direct Pod access)

# ============================================
# COMMANDS:
# ============================================
#
# Create Service:
#   kubectl apply -f 04-backend-service.yaml
#
# List Services:
#   kubectl get services -n studysync-dev
#   kubectl get svc -n studysync-dev  # Short form
#
# Describe Service:
#   kubectl describe service studysync-backend -n studysync-dev
#
# View Endpoints (Pods behind Service):
#   kubectl get endpoints studysync-backend -n studysync-dev
#
# Test Service from temporary Pod:
#   kubectl run -it --rm debug --image=curlimages/curl --restart=Never -n studysync-dev -- sh
#   # Inside Pod:
#   curl http://studysync-backend:3000/api/health
#
# Port-forward to Service:
#   kubectl port-forward service/studysync-backend 3000:3000 -n studysync-dev
#
# View Service in detail:
#   kubectl get service studysync-backend -n studysync-dev -o yaml
#
# Delete Service:
#   kubectl delete service studysync-backend -n studysync-dev
# ============================================

# ============================================
# SERVICE DISCOVERY:
# ============================================
#
# Kubernetes provides automatic DNS for Services:
#
# 1. Short name (same namespace):
#    studysync-backend
#
# 2. Full DNS name:
#    studysync-backend.studysync-dev.svc.cluster.local
#
# 3. Environment variables (injected into Pods):
#    STUDYSYNC_BACKEND_SERVICE_HOST=10.96.0.1
#    STUDYSYNC_BACKEND_SERVICE_PORT=3000
#
# Example from frontend Pod:
# ```javascript
# const API_URL = process.env.STUDYSYNC_BACKEND_SERVICE_HOST || 'studysync-backend';
# fetch(`http://${API_URL}:3000/api/users`);
# ```
# ============================================

# ============================================
# LOAD BALANCING:
# ============================================
#
# Service automatically load balances across Pods:
#
# Before Service:
#   Frontend → Pod 1 (10.244.0.5)
#   Frontend → Pod 2 (10.244.0.6)
#   Frontend → Pod 3 (10.244.0.7)
#   (Frontend needs to know all Pod IPs - BAD!)
#
# With Service:
#   Frontend → Service (10.96.0.1) → Round-robin to Pods
#   (Frontend only knows Service IP - GOOD!)
#
# Load balancing algorithm: Round-robin (default)
# Can be changed with annotations
# ============================================

# ============================================
# SERVICE vs DEPLOYMENT:
# ============================================
#
# Deployment:
# - Creates and manages Pods
# - Handles scaling, updates, rollbacks
# - Ensures desired number of Pods
#
# Service:
# - Provides network access to Pods
# - Load balances traffic
# - Provides stable endpoint
# - Doesn't create or manage Pods
#
# They work together:
# Deployment creates Pods → Service routes traffic to them
# ============================================

# ============================================
# TROUBLESHOOTING:
# ============================================
#
# Issue: Service has no endpoints
#   kubectl get endpoints studysync-backend -n studysync-dev
#   # If empty, check:
#   # 1. Service selector matches Pod labels
#   # 2. Pods are running and ready
#
# Issue: Can't connect to Service
#   # Test from debug Pod:
#   kubectl run -it --rm debug --image=nicolaka/netshoot -n studysync-dev -- bash
#   # Inside Pod:
#   nslookup studysync-backend
#   curl http://studysync-backend:3000/api/health
#
# Issue: Service connects to wrong Pods
#   kubectl get pods -n studysync-dev --show-labels
#   # Verify labels match Service selector
# ============================================
